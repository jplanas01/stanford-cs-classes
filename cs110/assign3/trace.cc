/**
 * File: trace.cc
 * ----------------
 * Presents the implementation of the trace program, which traces the execution of another
 * program and prints out information about ever single system call it makes.  For each system call,
 * trace prints:
 *
 *    + the name of the system call,
 *    + the values of all of its arguments, and
 *    + the system calls return value
 */

#include <cassert>
#include <iostream>
#include <map>
#include <set>
#include <unistd.h> // for fork, execvp
#include <string.h> // for memchr, strerror
#include <sys/ptrace.h>
#include <sys/reg.h>
#include <sys/wait.h>
#include "trace-options.h"
#include "trace-error-constants.h"
#include "trace-system-calls.h"
#include "trace-exception.h"
#include <sstream>
using namespace std;


/* Returns true if the child process being traced is still going (ie, has not
 * exited yet), false otherwise. status is updated with the result of waitpid,
 * nonSysTrap is set to true if a non-system call SIGTRAP was raised.
 * Assumes that the process is in a stopped state (ie, ready for a
 * PTRACE_SYSCALL)
 */
static bool stillGoing(pid_t child, int &status, bool &nonSysTrap) {
    ptrace(PTRACE_SYSCALL, child, 0, 0);
    waitpid(child, &status, 0);

    if (!(WIFSTOPPED(status) && WSTOPSIG(status) & 0x80)) {
        nonSysTrap = true;
    } else {
        nonSysTrap = false;
    }

    if (WIFEXITED(status)) {
        return false;
    }

    return true;
}

/* Prints a status message once the process dies.
 */
static void printDeath(int status) {
    cout << "<no return>" << endl;
    cout << "Program exited normally with status " << WEXITSTATUS(status) << endl;
}

/* Prints the syscall information for the --simple case for the child PID.
 */
static void printSimpleCall(pid_t child) {
    long callNum = ptrace(PTRACE_PEEKUSER, child, ORIG_RAX * sizeof(long));
    cout << "syscall(" << callNum << ") = ";
    cout << flush;
}

/* Reads a string from the child process specified in PID given a base address.
 * Assumes that the process is being traced, that the base is a valid address
 * within the other process, and that the string is a null-terminated C string.
 *
 * Returns the read string.
 */
static string readString(pid_t pid, long base) {
    ostringstream out;
    unsigned char bytes[sizeof(long) + 1];
    long read = 0;
    while (true) {
        *(long *)bytes = ptrace(PTRACE_PEEKDATA, pid, base + read);
        bytes[sizeof(long)] = '\0';
        out << bytes;
        if (memchr(bytes, '\0', sizeof(long)) != NULL) {
            break;
        }
        read += sizeof(long);
    }
    return out.str(); 
}

static const long registers[] = {RDI, RSI, RDX, R10, R8, R9};
/* Fetches a single argument that was used for a system call and return it as a
 * string.
 *
 * i specifies the argument index starting from 0, assumed to be valid.
 * sig is a vector of argument signatures, as generated by compileSystemCallData
 * child is the child process being traced.
 */
string getArgumentString(size_t i, systemCallSignature &sig, pid_t child) {
    ostringstream out;
    long data = ptrace(PTRACE_PEEKUSER, child, registers[i] * sizeof(long));
    switch(sig[i]) {
        case SYSCALL_INTEGER:
            out << (int)data;
            break;
        case SYSCALL_POINTER:
            if (data == 0) {
                out << "NULL";
            } else {
                out << (void *)data;
            }
            break;
        case SYSCALL_STRING:
            out << '"' << readString(child, data) << '"';
            break;
        default:
            out << "NIP";
    }
    return out.str();
}

/* Prints out the full information for a system call in a child process.
 *
 * child is the PID of the child process being traced
 * callNumbers, callNames, callSignatures are the hashmaps initialized by
 * compileSystemCallData
 */
static void printFullCall(pid_t child,
        map<int, string> &callNumbers, 
        map<string, int> &callNames, 
        map<string, systemCallSignature> &callSignatures) {

    long callNum = ptrace(PTRACE_PEEKUSER, child, ORIG_RAX * sizeof(long));
    cout << callNumbers[callNum] << "(";

    if (callSignatures.find(callNumbers[callNum]) == callSignatures.end()) {
        cout << "<signature-information-missing>";
    }

    // If map doesn't have a key, it'll return an empty vector: don't need
    // special case to handle this.
    systemCallSignature sig = callSignatures[callNumbers[callNum]];
    size_t args = sig.size();

    if (args > 0) {
        size_t i;
        cout << getArgumentString(0, sig, child);
        for (i = 1; i < args - 1; i++) {
            cout << ", " << getArgumentString(i, sig, child);
        }
        if (args > 1) {
            cout << ", " << getArgumentString(i, sig, child);
        }
    }

    cout << ") = ";
    cout << flush;
}

/* Prints out the simple return information for a given system call.
 */
static void printSimpleRet(pid_t child) {
    long retVal = ptrace(PTRACE_PEEKUSER, child, RAX * sizeof(long));
    cout << retVal << endl;
}

/* Prints out the full system call return information for a given system call in
 * the traced child process.
 *
 * child is the PID of the traced process, errorConstants is the map initialized
 * by compileSystemCallErrorStrings.
 */
static void printFullRet(pid_t child, map<int, string> &errorConstants) {
    long callNum = ptrace(PTRACE_PEEKUSER, child, ORIG_RAX * sizeof(long));
    long retVal = ptrace(PTRACE_PEEKUSER, child, RAX * sizeof(long));
    if (retVal >= 0) {
        switch (callNum) {
            /* Need to convert values from brk and mmap to pointers. 9 and 12
             * are the values for brk and mmap, sbrk is implemented as brk so
             * don't need to handle that case separately.
             */
            case 9:
            case 12:
                cout << (void *)retVal << endl;
                break;
            default:
                cout << (int)retVal << endl;
        }

    } else {
        cout << "-1 " << errorConstants[abs(retVal)] << " (";
        cout << strerror(abs(retVal)) << ")" << endl;
    }
}

/* Spawns a process, sets it to be traced, and replaces itself with the process
 * to be traced. raises SIGTRAP to allow time for the parent process to ready
 * itself to harvest system calls.
 */
static pid_t spawn_tracee(char *argv[]) {
    pid_t pid = fork();
    if (pid == 0) {
        
        ptrace(PTRACE_TRACEME);
        raise(SIGTRAP);
        execvp(argv[0], argv);
        exit(1);
    }

    return pid;
}

/* Runs the trace, printing information about all system calls executed by the
 * tracee, until the process exits.
 *
 * argv is a null-terminated vector of arguments to be passed into execvp.
 * simple indicates whether to provide simple or full output
 * callNumbers, callNames, callSignatures are the hashmaps generated by
 * compileSystemCallData.
 * errorConstants is the hashmap generated by compileSystemCallErrorStrings
 * 
 * Returns the exit status of the tracee.
 */
static int runTrace(char *argv[], bool simple,
        map<int, string> &callNumbers, 
        map<string, int> &callNames, 
        map<string, systemCallSignature> &callSignatures,
        map<int, string> &errorConstants) {

    pid_t child = spawn_tracee(argv);
    int status;
    waitpid(child, &status, 0);
    ptrace(PTRACE_SETOPTIONS, child, 0, PTRACE_O_TRACESYSGOOD);
    bool nonSysTrap = true;

    while (true) {
        if (!stillGoing(child, status, nonSysTrap)) {
            break;
        }
        if (nonSysTrap) {
            continue;
        }

        if (simple) {
            printSimpleCall(child);
        } else {
            printFullCall(child, callNumbers, callNames, callSignatures);
        }

        if (!stillGoing(child, status, nonSysTrap)) {
            printDeath(status);
            return WEXITSTATUS(status);
        }

        if (simple) {
            printSimpleRet(child);
        } else {
            printFullRet(child, errorConstants);
        }
    }
}


int main(int argc, char *argv[]) {
    bool simple = false, rebuild = false;
    int numFlags = processCommandLineFlags(simple, rebuild, argv);
    if (argc - numFlags == 1) {
        cout << "Nothing to trace... exiting." << endl;
        return 0;
    }

    map<int, string>errorConstants;
    try {
        compileSystemCallErrorStrings(errorConstants);
    } catch (MissingFileException e) {
        cout << e.what() << endl;
        return 1;
    }

    map<int, string>callNumbers;
    map<string, int>callNames;
    map<string, systemCallSignature>callSignatures;
    try {
        compileSystemCallData(callNumbers, callNames, callSignatures, rebuild);
    } catch (MissingFileException e) {
        cout << e.what() << endl;
        return 1;
    }

    return runTrace(&argv[numFlags + 1], simple, callNumbers, callNames, callSignatures, errorConstants);
}
